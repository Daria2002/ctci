#include <iostream>

/**
 * Context Switch: How would you measure the time spent in a context switch?
*/
int main() {
    std::cout <<
    "A context swith is the time spent switching between two processes (i.e., bringing a\n"
    "waiting process into execution and sending an executing process into waiting/terminated\n"
    "state). This happens in multitasking. The operating system must bring the state information\n"
    "of waiting processes into memory and save the state information of the currently running\n"
    "process. In order to solve this problem, we would like to record the timestamps of the\n"
    "last and first instruction of the swapping processes. The context switch time is the\n"
    "difference in the timestamps between the two processes. Assume there are only 2\n"
    "processes, P1 and P2. P1 is  executing and P2 is waiting for execution. At some point,\n"
    "the operating system must swap P1 and P2 - let's assume it happens at the Nth instruction\n"
    "of P1. If tx,k indicates the timestamp in microseconds of the kth instruction of process\n"
    "x, than the context switch would take t2,1 - t1,n  microseconds. The tricky part is this:\n"
    "how do we know when this swapping occurs? We cannot, of course, record the time-stamp\n"
    "of every instruction in the process. Another issue is that swapping is governed by the\n"
    "scheduling algorithm of the operating system and there may be many kernel level threads\n"
    "which are also doing context switches. Other processes could be contending for the CPU or\n"
    "the kernel handling interrupts. The user doesn't have any control over these extraneous\n"
    "context switches. For instance, if at time t1,n the kernel decides to handle an interrupt,\n"
    "then the context switch time would be overstated. In order to overcome these obstacles,\n"
    "we must first construct an environment such that after P1 executes, the task scheduler\n"
    "immediately selects P2 to run. This may be accomplished by constructing a data channel,\n"
    "such as a pipe, between P1 and P2 and having the two processes play a game of ping-pong\n"
    "with a data token. That is, let's allow P1 to be the initial sender and P2 to be the\n"
    "receiver. Initially, P2 is blocked (sleeping) as it awaits the data token. When P1\n"
    "executes, it delivers the token over the data channel to P2 and immediately attempts\n"
    "to read a response token. However, since P2 has not yet had a chance to run, no such\n"
    "token is available for P1 and the process is blocked. This relinquishes the CPU. A\n"
    "context switch results and the task scheduler must select another process to run.\n"
    "Since P2 is now in a ready-to-run state, it is a desirable candidate to be selected\n"
    "by the task scheduler for execution. When P2 runs, the roles P1 and P2 are swapped.\n"
    "P2 is now acting as the sender and P1 as the blocked receiver. The game ends when P2\n"
    "returns the token to P1. To summarize, an iteration of the game is played with the\n"
    "following steps:\n"
    "1. P2 blocks awaiting data from P1.\n"
    "2. P1 marks the start time.\n"
    "3. P1 sends token to P2.\n"
    "4. P1 attempts to read a response token from P2. This induces a context switch.\n"
    "5. P2 is scheduled and receives the token.\n"
    "6. P2 sends a response token to P1.\n"
    "7. P2 attempts to read a response token from P1. This induces a context switch.\n"
    "8. P1 is scheduled and receives the token.\n"
    "9. P1 marks the end time.\n"
    "The key is that the delivery of a data token induces a context switch. Let Td and Tr\n"
    "be the time it takes to deliver and receive a data token, respectively, and let Tc\n"
    "be the amount of time spent in a context switch. At step 2, P1 records the timestamp\n"
    "of the delivery of the token, and at step 9, it records the timestamp of the response.\n"
    "The amount of time elapsed, T, between these events may be expressed by:\n"
    "T = 2 * (Td + Tc + Tr)\n"
    "This formula arises beacuse of the following events: P1 sends a token(3), the CPU context\n"
    "switches(4), P2 receives it(5). P2 then sends the response token(6), the CPU context\n"
    "switches(7), and finally P1 receives it(8). P1 will be able to easily compute T, since\n"
    "this is just the time between events 3 and 8. So, to solve for Tc, we must first determine\n"
    "the value of Td + Tr. How can we do this? We can do this by measuring the length of time\n"
    "it takes P1 to send and receive a token to itself. This will not induce a context switch\n"
    "since P1 is running on the CPU at the time it sent the token and will not block to receive it.\n"
    "The game is played a number of iterations to average out any variability in the elapsed time\n"
    "between steps 2 and 9 that may result from unexpected kernel interrupts and additional\n"
    "kernel threads contending for the CPU. We select the smallest observed context switch\n"
    "time as out final answer. However, all we can ultimately say that this is an approximation\n"
    "which depends on the underlying system. For example, we make the assumption that P2 is\n"
    "selected to run once a data token becomes available. However, this is dependent on the\n"
    "implementation of the task scheduler and we cannot make and guarantees.\n";
}
