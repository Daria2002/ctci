#include <iostream>

/**
 * Explain how you would design a personal financial manager (likeMint.com).This system would connect
 * to your bank accounts, analyze your spending habits, and make recommendations.
 */
int main() {
    std::cout << "Personal Financial Manager is write-heavy problem because there is a lot of data coming in,\n"
                 "but it's rarely being read. As much work as possible should be done asynchronously. It means\n"
                 "that we can execute multiple things at the time and we don't have to finish executing the current\n"
                 "thing in order to move on to the next one.\n"
                 "Step 1: Scope the Problem\n"
                 "  - the financial history includes outgoing money, incoming money and current money\n"
                 "  - just websit for now, although it could potentially be a mobile app as well\n"
                 "  - email notification on regular basis or on certain conditions (spending over a certain treshold...)\n"
                 "Step 2: Make Reasonable Assumptions\n"
                 "  - the system is write-heavy because a typical user may take several new transactions daily, although few\n"
                 "    users would access the website more than once a week. In fact, for many users, their primary interaction\n"
                 "    might be through email alerts.\n"
                 "  - the bank won't push data to our system, we will need to pull data from the banks.\n"
                 "  - alerts on users exceeding budgets do not neeed to be sent instantaneously. It's pretty safe for them to be\n"
                 "    up to 24 hours delayed.\n"
                 "Step 3: Draw Major Components\n"
                 "  bank data synchronizer -> raw transaction data -> categorizer -> categorized transactions -> budget analyzer -> budget data\n"
                 "                                                                                     -----------> frontend <--------\n"
                 "  - the bank data is pulled at periodic times and stored in some list of raw, unprocessed transactions. This data is then pushed to\n"
                 "    the categorizer which assigns each transaction to the category and stores these transactions in another datastore called\n"
                 "    categorized transactions. The budget analyzer pulls in the categorized transactions and updates each user's budget per\n"
                 "    category, and stores the user's budget. The frontend pulls data from both categorized transactions datastore as well as from the\n"
                 "    budget datastore. A user could also interact with the frontend by changing the budget or the categorization of their transactions.\n"
                 "Step 4: Identify the Key Issues\n"
                 "  - This is data-heavy system and since we want it to feel snappy (quick) and responsive we'll want as much processing as possible\n"
                 "    to be asynchronous. There should be at least one task queue where we can queue up work that needs to be done (pulling in new bank data,\n"
                 "    re-analyzing budgets, and categorizing new bank data). A task queue system should be able to prioritize some task types over others,"
                 "    but we wouldn't want a low priority tasks to \"starve\" because there is always higher priority tasks. There will probably be a large\n "
                 "    number of inactive users - users who signed up once and then haven't touched the system since. The syste should entirely remove them or\n"
                 "    deprioritize their accounts. The biggest bottleneck in system like this is a massive amount of data that needs to be pulled and analyzed.\n"
                 "    As soon as we get a transaction for a user, we can categorize it and integrate and integrate this data. It might not be very efficient because\n"
                 "    a lots of transactions are coming in at once. We should not use a standard db because we certainly don't want to do a bunch of joins.\n"
                 "    It may be better to store the transactions to a set of flat text files. If we're assuming a lot of users, then there will be a lot of duplicates\n"
                 "    across the sellers. If we group the transaction files by seller's name, we can take advantage of these duplicates. The categorizer can do something\n"
                 "    like this: raw transaction data, grouped by seller -> categorized data, grouped by user -> update categorized transactions\n"
                 "                                                                           |\n"
                 "                                                          merge & group by user & category\n"
                 "                                                                           |\n"
                 "                                                                   update budgets\n"
                 "    Categorizer gets the raw transaction data, grouped by seller. It picks the appropriate category for the seller(which might be stored in a cache\n"
                 "    for the most common sellers), and then applies that category to all those transactions. After applying the category, it re-groups all the transactions\n"
                 "    by user. Those transactions are inserted into the database for this user. The categorizer takes the data grouped by user and merges it across categories\n"
                 "    and updates the budget. Most of these tasks will be handled in simple log files, only final data(the categorized transactions and budget analysis) will\n"
                 "    be stored in a db. That will minimize reading and writing in db.\n";
}
